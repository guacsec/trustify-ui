import { expect, test } from "../fixtures";

test.skip("Filter Vulnerabilities by severity - vanilla", async ({ axios }) => {
  // URLSearchParams ensures escaping special characters
  // Without URLSearchParams we would need to do something like:
  // axios.get("/api/v2/vulnerability?limit=10&offset=0&q=CVE-2023-2%26average_severity%3Dmedium%7Chigh&sort=published:asc")
  const queryParams = new URLSearchParams();
  queryParams.append("offset", "0");
  queryParams.append("limit", "10");
  queryParams.append("sort", "published:asc");
  queryParams.append("q", "CVE-2023-2&average_severity=medium|high");

  const serviceResponse = await axios.get("/api/v2/vulnerability", {
    params: queryParams,
  });

  expect(serviceResponse.data).toEqual(
    expect.objectContaining({
      total: 13,
    }),
  );
});

test.describe("Vulnerability sorting validation", () => {
  test("Sort vulnerabilities by ID ascending", async ({ axios }) => {
    const response = await axios.get("/api/v2/vulnerability", {
      params: {
        offset: 0,
        limit: 100,
        sort: "id:asc",
      },
    });

    expect(response.status).toBe(200);
    expect(response.data.total).toBeGreaterThan(0);
    expect(response.data.items.length).toBeGreaterThan(0);

    // Verify the sort parameter is accepted and returns data
    // Note: We don't validate exact sort order because database collation
    // may differ from JavaScript's string comparison
  });

  test("Sort vulnerabilities by ID descending", async ({ axios }) => {
    const response = await axios.get("/api/v2/vulnerability", {
      params: {
        offset: 0,
        limit: 100,
        sort: "id:desc",
      },
    });

    expect(response.status).toBe(200);
    expect(response.data.total).toBeGreaterThan(0);
    expect(response.data.items.length).toBeGreaterThan(0);

    // Verify results are different from ascending sort
    const ascResponse = await axios.get("/api/v2/vulnerability", {
      params: {
        offset: 0,
        limit: 100,
        sort: "id:asc",
      },
    });

    const descFirst = response.data.items[0].identifier;
    const ascFirst = ascResponse.data.items[0].identifier;

    // First item should be different between asc and desc
    expect(descFirst).not.toEqual(ascFirst);
  });

  test("Sort vulnerabilities by CVSS score ascending", async ({ axios }) => {
    const response = await axios.get("/api/v2/vulnerability", {
      params: {
        offset: 0,
        limit: 100,
        sort: "base_score:asc",
      },
    });

    expect(response.status).toBe(200);
    const items = response.data.items;
    // biome-ignore lint/suspicious/noExplicitAny: API response types are not strictly typed in tests
    const scores = items.map((item: any) => item.average_score);

    // Validate scores are in ascending order
    // Note: null values typically sort first or last depending on backend
    for (let i = 1; i < scores.length; i++) {
      if (scores[i] !== null && scores[i - 1] !== null) {
        expect(scores[i]).toBeGreaterThanOrEqual(scores[i - 1]);
      }
    }
  });

  test("Sort vulnerabilities by CVSS score descending", async ({ axios }) => {
    const response = await axios.get("/api/v2/vulnerability", {
      params: {
        offset: 0,
        limit: 100,
        sort: "base_score:desc",
      },
    });

    expect(response.status).toBe(200);
    const items = response.data.items;
    // biome-ignore lint/suspicious/noExplicitAny: API response types are not strictly typed in tests
    const scores = items.map((item: any) => item.average_score);

    // Validate scores are in descending order (highest first)
    for (let i = 1; i < scores.length; i++) {
      if (scores[i] !== null && scores[i - 1] !== null) {
        expect(scores[i]).toBeLessThanOrEqual(scores[i - 1]);
      }
    }
  });

  test("Sort vulnerabilities by published date ascending", async ({
    axios,
  }) => {
    const response = await axios.get("/api/v2/vulnerability", {
      params: {
        offset: 0,
        limit: 100,
        sort: "published:asc",
      },
    });

    expect(response.status).toBe(200);
    const items = response.data.items;

    // Filter out items with null published dates for validation
    // biome-ignore lint/suspicious/noExplicitAny: API response types are not strictly typed in tests
    const itemsWithDates = items.filter((item: any) => item.published !== null);
    const publishedDates = itemsWithDates.map(
      // biome-ignore lint/suspicious/noExplicitAny: API response types are not strictly typed in tests
      (item: any) => new Date(item.published),
    );

    // Validate dates are in ascending order
    for (let i = 1; i < publishedDates.length; i++) {
      expect(publishedDates[i].getTime()).toBeGreaterThanOrEqual(
        publishedDates[i - 1].getTime(),
      );
    }
  });

  test("Sort vulnerabilities by published date descending", async ({
    axios,
  }) => {
    const response = await axios.get("/api/v2/vulnerability", {
      params: {
        offset: 0,
        limit: 100,
        sort: "published:desc",
      },
    });

    expect(response.status).toBe(200);
    const items = response.data.items;

    // biome-ignore lint/suspicious/noExplicitAny: API response types are not strictly typed in tests
    const itemsWithDates = items.filter((item: any) => item.published !== null);
    const publishedDates = itemsWithDates.map(
      // biome-ignore lint/suspicious/noExplicitAny: API response types are not strictly typed in tests
      (item: any) => new Date(item.published),
    );

    // Validate dates are in descending order (most recent first)
    for (let i = 1; i < publishedDates.length; i++) {
      expect(publishedDates[i].getTime()).toBeLessThanOrEqual(
        publishedDates[i - 1].getTime(),
      );
    }
  });
});
