import React from "react";

import { VulnerabilityStatus } from "@app/api/models";
import { client } from "@app/axios-config/apiInit";
import {
  getSbom,
  SbomSummary,
  VulnerabilityAdvisorySummary,
} from "@app/client";
import { useFetchVulnerabilityById } from "@app/queries/vulnerabilities";

interface SbomOfVulnerability {
  sbomId: string;
  advisory: VulnerabilityAdvisorySummary;
  status: VulnerabilityStatus;
  sbom?: SbomSummary;
}

export interface SbomOfVulnerabilitySummary {
  total: number;
  status: { [key in VulnerabilityStatus]: number };
}

const DEFAULT_SUMMARY: SbomOfVulnerabilitySummary = {
  total: 0,
  status: { affected: 0, fixed: 0, known_not_affected: 0, not_affected: 0 },
};

export const useSbomsOfVulnerability = (sbomId: string) => {
  const {
    vulnerability,
    isFetching: isFetchingAdvisories,
    fetchError: fetchErrorAdvisories,
  } = useFetchVulnerabilityById(sbomId);

  const [allSboms, setAllSboms] = React.useState<SbomOfVulnerability[]>([]);
  const [sbomsById, setSbomsById] = React.useState<Map<string, SbomSummary>>(
    new Map()
  );
  const [isFetchingSboms, setIsFetchingSboms] = React.useState(false);

  React.useEffect(() => {
    if (vulnerability?.advisories?.length === 0) {
      return;
    }

    const sboms = (vulnerability?.advisories ?? [])
      .flatMap((advisory) => {
        return (advisory.sboms ?? []).flatMap((sbom) => {
          return sbom.status.map((status) => {
            const result: SbomOfVulnerability = {
              sbomId: sbom.id,
              status: status as VulnerabilityStatus,
              advisory: { ...advisory },
            };
            return result;
          });
        });
      })
      // Remove duplicates if exists
      .reduce((prev, current) => {
        const exists = prev.find(
          (item) =>
            item.sbomId === current.sbomId &&
            item.advisory.uuid === current.advisory.uuid
        );
        if (!exists) {
          return [...prev, current];
        } else {
          return prev;
        }
      }, [] as SbomOfVulnerability[]);

    setAllSboms(sboms);
    setIsFetchingSboms(true);

    Promise.all(
      sboms
        .map(async (item) => {
          const response = await getSbom({
            client,
            path: { id: item.sbomId },
          });
          return response.data;
        })
        .map((sbom) => sbom.catch(() => null))
    ).then((sboms) => {
      const validSboms = sboms.reduce((prev, current) => {
        if (current) {
          return [...prev, current];
        } else {
          // Filter out error responses
          return prev;
        }
      }, [] as SbomSummary[]);

      const sbomsById = new Map<string, SbomSummary>();
      validSboms.forEach((sbom) => sbomsById.set(sbom.id, sbom));

      setSbomsById(sbomsById);
      setIsFetchingSboms(false);
    });
  }, [vulnerability]);

  const allSbomsWithMappedData = React.useMemo(() => {
    return allSboms.map((item) => {
      const result: SbomOfVulnerability = {
        ...item,
        sbom: sbomsById.get(item.sbomId),
      };
      return result;
    });
  }, [allSboms, sbomsById]);

  // Summary

  const sbomsSummary = React.useMemo(() => {
    return allSbomsWithMappedData.reduce((prev, current) => {
      if (current.status) {
        const status = current.status;
        return {
          ...prev,
          total: prev.total + 1,
          status: {
            ...prev.status,
            [status]: prev.status[status] + 1,
          },
        };
      } else {
        return prev;
      }
    }, DEFAULT_SUMMARY);
  }, [allSbomsWithMappedData]);

  return {
    isFetching: isFetchingAdvisories || isFetchingSboms,
    fetchError: fetchErrorAdvisories,
    sboms: allSbomsWithMappedData,
    summary: sbomsSummary,
  };
};
